[{"authors":null,"categories":null,"content":"","date":1640995200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1640995200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"","tags":null,"title":"Yunwei Hu","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature. Slides can be added in a few ways:\nCreate slides using Wowchemy’s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes. Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"/talk/example-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example-talk/","section":"event","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"event"},{"authors":[],"categories":["Reliability","simulation"],"content":" Repost of old blog post.\nSimulation of Repairable Systems First things first, this is not blog post. It is a summary of some codes I wrote a while back. Later similar efforts were continued in Python.\nThe objective to develop some Python DES tools for simple series/parallel systems, similar to the Reliability Analytics Toolkit by Seymour Morris. The pet project for this month :)\nThe GRP Model for Parametric Recurrent Event Data Analysis We follow the convention in [Ref 1] (http://www.weibull.com/hotwire/issue59/relbasics59.htm). (Fix typo in type II eq.)\nIn this model, the concept of virtual age is introduced. Denote by t1,t2,…,tn the successive failure times and let x1,x2,…,x3 represent the time between failures. Assume that after each event, actions are taken to improve the system performance. Let q be the action effectiveness factor. There are two GRP models. - Type I: \\(v_i = v_{i-1} + q \\cdot x_i = q \\cdot t_i\\) - Type II: \\(v_i = q \\cdot (v_{i-1} + x_i )= \\sum_{k=1}^i q^{i-k+1} \\cdot x_k\\) where \\(v_i\\) is the virtual age of the system right after the ith repair. The Type I model assumes that the $i^{th} repair cannot remove the damage incurred before the \\(i^{th}\\) failure. It can only reduce the additional age \\(x_i\\) to \\(q \\cdot x_i\\). The Type II model assumes that at the \\(i^{th}\\) repair, the virtual age has been accumulated to \\(v_{i-1} + x_i\\). The \\(i^{th}\\) repair will remove the cumulative damage from both current and previous failures by reducing the virtual age to \\(q \\cdot (v_{i-1} + x_i )\\).\nAnalytical solution and Simulation There is no close form for the renewal function E(N(t)) of General Renewal Process , except for some special cases, such as where the q = 1 (as-bad-as-old, or NHPP) or q = 0 (as-good-as-new). Monte Carlo simulation can be used but it is desirable to find an approximation equation of renewal function for speed.\nPower Law NHPP (as-bad-as-old) The power law function is used to model the rate of recurrence, which is: \\(\\lambda(t) = \\lambda\\beta t^{\\beta-1}\\)\nThe conditional pdf is \\(f(t_i|t_{i-1}) = \\lambda \\beta (x_i + v_{i-1})^{\\beta-1} \\cdot e^{-\\lambda[(x_i + v_{i-1})^\\beta - V_{i-1}^\\beta]}\\)\nComparing the ROCOF with Weibull hazard function, we can get: \\(\\lambda = \\frac{1}{\\eta^\\beta}\\) or \\(\\eta = (\\frac{1}{\\lambda})^{\\frac{1}{\\beta}}\\)\nTest the simulation Test the simulation. - Matraix is much faster than data frame.\nsimGRP The simDRA function returns the data frame of the simulation results, given alpha, beta, q.\nlibrary(tidyverse) # Function to simulate the General Renewal Process # Input, Weibull(Scale and Shape) simGRP \u0026lt;- function (scale, shape = 1, q = 1, n_sim = 1e4, n_failure = 25) { ttf \u0026lt;- matrix(NA, n_failure, n_sim ) # generate time to 1st failure ttf[1, ] \u0026lt;- rweibull(n_sim, scale = scale, shape = shape) v_time \u0026lt;- ttf[1, ] * q # generating time to ith failure - inverse of conditional Weibull CDF for (i in 2:n_failure) { # rand \u0026lt;- runif(n_sim) ttf[i, ] \u0026lt;- scale *( ( (v_time/scale)^shape - log(1 - runif(n_sim)) )^(1 / shape)) - v_time + ttf[i-1, ] v_time \u0026lt;- q * ttf[ i, ] } #Return data frame ttf \u0026lt;- tibble(time_to_f = as.vector(ttf), count_f = rep(1:n_failure, n_sim), simid = rep(1:n_sim, each = n_failure)) } # start clock ptm \u0026lt;- proc.time() ttf \u0026lt;- simGRP( scale = 100, shape = 1, q = 0, n_sim = 1e6, n_failure = 25) proc.time() - ptm ## user system elapsed ## 2.588 0.222 2.853 Data analyis Build the functions for Data Analysis Expected Time to failure Pr(N = n, Time \u0026lt; t) Pr(N \u0026gt;= n, Time \u0026lt; t) Expected N(t) ttn \u0026lt;- function (data) { time_to_failure \u0026lt;- ttf %\u0026gt;% group_by(count_f) %\u0026gt;% summarise(avg = mean(time_to_f)) } cumprob \u0026lt;- function( data, count_failure, time_p ) { dims \u0026lt;- data %\u0026gt;% filter(count_f \u0026gt;= count_failure \u0026amp; time_to_f \u0026lt; time_p) %\u0026gt;% dim() dims[1]/dim(data)[1]} prob \u0026lt;- function( data, count_failure, time_p ) { dims \u0026lt;- data %\u0026gt;% filter(count_f == count_failure \u0026amp; time_to_f \u0026lt; time_p) %\u0026gt;% dim() dims[1]/dim(data)[1]} prob(ttf, 3, 10000) ## [1] 0.04 cumprob(ttf, 3, 10000) ## [1] 0.92 # verify cumprob cprob = 0 for (i in 3:40){ cprob = cprob + prob(ttf, i, 10000)} cprob ## [1] 0.92 # Expected N(t) E_Nt \u0026lt;- function (data, t){ dims \u0026lt;- data %\u0026gt;% filter(time_to_f \u0026lt; t) %\u0026gt;% dim() dims[1]/length(unique(data$simid)) } Compare “Expected N(t)” with Expected “Time to nth failure” ** “Time at which E[N(t)] = n” != Expected “Time to nth failure” **\ntime_to_nth \u0026lt;- ttn(ttf) ent \u0026lt;- sapply(as_vector(time_to_nth[,2]), function(x) E_Nt(ttf, x)) # plot(1:25, ent) # abline(0,1) time_to_nth \u0026lt;- tibble(count_f = c(1:25, ent), time = as_vector(rep(time_to_nth[,2],2)), src = rep(c(\u0026#34;ttf\u0026#34;, \u0026#34;ent\u0026#34;), each = 25)) ggplot(time_to_nth, aes(x = time, y = count_f)) + geom_point(aes(color = src)) Discrete Event Simulation The Monte Carlo simulation discussd above is applicable to a single repairable block. The general renewal process also assumes minimal repair downtime. In plant reliability/availabilit analysis, we often deal with long outage time, planning resources etc. The Monte Carlo …","date":1658966400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1659076932,"objectID":"16445ed396bdda339bb662512a4fc2fa","permalink":"/post/simulation-for-reliability-engineering/","publishdate":"2022-07-28T00:00:00Z","relpermalink":"/post/simulation-for-reliability-engineering/","section":"post","summary":"Repost of old blog post.\nSimulation of Repairable Systems First things first, this is not blog post. It is a summary of some codes I wrote a while back. Later similar efforts were continued in Python.","tags":["Repairable","rstats"],"title":"Simulation for Reliability Engineering","type":"post"},{"authors":[],"categories":["simulation"],"content":" This is a repost of the bolg by me dated 2018-05-21.\n#prepare the libraries library(tidyverse) library(simmer) library(simmer.plot) library(intervals) Simmer for R In my short experiment with Simpy and Simmer, Simmer shines in one area: monitoring. In Simpy a list can be passed to the simulation, and it is flexible to choose what to code.\nWith Simmer, three commands get_mon_arrivals(), get_mon_attributes(), get_mon_resources() can generate the story book of the simulation. The story is in data.frame format, and can be easily processed in R.\nLet’s use the Machine Shop as an Example.\nInstead of print out the events in user interface with log_(), we make the simulation invisible, and add an attribute to log the state (working, fail).\nmachine \u0026lt;- function(mttf, repair_time){ machie \u0026lt;- trajectory() %\u0026gt;% # machine_state: 1-working, 0-fail set_attribute(\u0026#34;machine_state\u0026#34;, 1) %\u0026gt;% timeout(function() rexp(1, 1/mttf)) %\u0026gt;% set_attribute(\u0026#34;machine_state\u0026#34;, -1, mod=\u0026#34;+\u0026#34;) %\u0026gt;% seize(\u0026#34;repairman\u0026#34;) %\u0026gt;% timeout(repair_time) %\u0026gt;% release(\u0026#34;repairman\u0026#34;) %\u0026gt;% set_attribute(\u0026#34;machine_state\u0026#34;, 1, mod=\u0026#34;+\u0026#34;) %\u0026gt;% rollback(6) } plot(machine(10,1)) Make it a function.\nsimmer_relia \u0026lt;- function(sim_time, mon_ = \u0026#34;attributes\u0026#34;) { env \u0026lt;- simmer() %\u0026gt;% # use resource to track system state # all items in series will require same \u0026#34;repair\u0026#34; resource. # set capacity to inf, assuming no queue for repair # if repair resource busy -\u0026gt; system down # for n-oo-k items, if resource server \u0026gt; k-n -\u0026gt;system down add_resource(\u0026#34;repairman\u0026#34;, capacity = Inf) %\u0026gt;% add_generator(\u0026#34;machine_a\u0026#34;, machine(100, 10), at(0), mon = 2) %\u0026gt;% add_generator(\u0026#34;machine_b\u0026#34;, machine(100, 5), at(0), mon = 2) %\u0026gt;% run(sim_time) %\u0026gt;% invisible if (mon_==\u0026#34;resources\u0026#34;){ sim_log \u0026lt;- get_mon_resources(env) } else if (mon_==\u0026#34;attributes\u0026#34;) { sim_log \u0026lt;- get_mon_attributes(env) } sim_log } Loop for replications N_RUN \u0026lt;- 10 SIM_END = 500 ptm \u0026lt;- proc.time() machine_state_log \u0026lt;- 1:N_RUN %\u0026gt;% map_df(function(x) cbind(simmer_relia(SIM_END), tibble(i_run = x))) simmer_time \u0026lt;- proc.time() - ptm tail(machine_state_log) ## time name key value replication i_run ## 209 442.3666 machine_b0 machine_state 0 1 10 ## 210 447.3666 machine_b0 machine_state 1 1 10 ## 211 462.9960 machine_a0 machine_state 0 1 10 ## 212 472.8377 machine_b0 machine_state 0 1 10 ## 213 472.9960 machine_a0 machine_state 1 1 10 ## 214 477.8377 machine_b0 machine_state 1 1 10 Test\nsimu_attributes \u0026lt;- simmer_relia(500) print(simu_attributes) ## time name key value replication ## 1 0.00000 machine_a0 machine_state 1 1 ## 2 0.00000 machine_b0 machine_state 1 1 ## 3 42.28105 machine_b0 machine_state 0 1 ## 4 47.28105 machine_b0 machine_state 1 1 ## 5 77.35852 machine_a0 machine_state 0 1 ## 6 87.35852 machine_a0 machine_state 1 1 ## 7 98.15019 machine_b0 machine_state 0 1 ## 8 103.15019 machine_b0 machine_state 1 1 ## 9 111.34813 machine_a0 machine_state 0 1 ## 10 121.34813 machine_a0 machine_state 1 1 ## 11 151.84864 machine_a0 machine_state 0 1 ## 12 161.84864 machine_a0 machine_state 1 1 ## 13 179.71953 machine_b0 machine_state 0 1 ## 14 184.71953 machine_b0 machine_state 1 1 ## 15 236.37764 machine_b0 machine_state 0 1 ## 16 241.37764 machine_b0 machine_state 1 1 ## 17 259.25923 machine_a0 machine_state 0 1 ## 18 269.25923 machine_a0 machine_state 1 1 ## 19 397.68679 machine_a0 machine_state 0 1 ## 20 407.68679 machine_a0 machine_state 1 1 simu_resources \u0026lt;- simmer_relia(500, mon = \u0026#34;resources\u0026#34;) plot(simu_resources, metric = \u0026#34;usage\u0026#34;, \u0026#34;repairman\u0026#34;, items = \u0026#34;server\u0026#34;, steps = TRUE) Monitoring: resources vs attributes With simmer, by adding user-defined attributes, we can log the simualtion flexibly. In the context of the system reliability, since only one “repariman” resource is requested when ANY of the machines fail, the “repairman” resource can be used directly for simple system reliability metrics. If the it is series system, whenever the repairman is busy, the system is down. Or it is n-out-of-k, then \u0026gt;= n simultaneous “repairs” implies system down.\nThe attribute logs the state of all the “machines”, it is more flexible to use the attributes. We are interest in the event sequence of the system down time, the Intervals pacakge, which provides a collections of operation on intervals over the real number line (R), is helpful the determine the system state base on the component state.\nIn the example above, we have the event sequence of the machine_a and machine_b, so for a parellel system, the intersection of downtime interval is the system down time. and for a series system, union.\nConvert event sequences to state intervals machine_state_interval \u0026lt;- function(machine_state_log){ machine_state_log %\u0026gt;% group_by(i_run, name) %\u0026gt;% arrange(time) %\u0026gt;% # end_time is lead(start_time) (remove leading NA), last one is sim_end mutate(end_time = c(head(lead(time), -1), SIM_END)) %\u0026gt;% ungroup() %\u0026gt;% dplyr::select(name, value, start_time = time, end_time, i_run) %\u0026gt;% arrange(i_run, name, start_time) } state_interval \u0026lt;- machine_state_interval(machine_state_log) machine_down_interval \u0026lt;- …","date":1658534400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658611876,"objectID":"ff303710793249ba3946a9845889c502","permalink":"/post/discrete-event-simulation-part-ii/","publishdate":"2022-07-23T00:00:00Z","relpermalink":"/post/discrete-event-simulation-part-ii/","section":"post","summary":"This is a repost of the bolg by me dated 2018-05-21.\n#prepare the libraries library(tidyverse) library(simmer) library(simmer.plot) library(intervals) Simmer for R In my short experiment with Simpy and Simmer, Simmer shines in one area: monitoring.","tags":["DES","rstats","Repairable"],"title":"Discrete Event Simulation - Part II","type":"post"},{"authors":[],"categories":["Reliability"],"content":" Repost The inline latex was not rendered if use .Rmarkdown extension, but it works when the extension is .Rmd. Most Widely Used Distribution in Reliability Engineering Weibull distribution is widely used because its flexibility and simplicity. It is the most widely used in the field of reliability engineering. Engineers use Weibull plot to find clues about whether the failure is infant mortality or wearing out, or use the curve shape to determine whether there are more than one underlying failure mechanisms. Actually, there are several software companies selling software packages named after the Swedish Engineer.\nParameterizations When I mentioned the simplicity of Weibull distribution, I was referring to that it has only two paraments, and both of them have significannt engineering interprations.\nShape and Scale One of the most popular Reliability Engineering software package is Weibull++ (r) made by Reliasoft. The company also maintains the website [www.weibull.com]. It provides wealth of information of reliability engineering, and especially, Weibull distribution and its applications. In their implentation, the Weibull distribution has a characteristic life parameter \\(\\eta\\) and a shape factor \\(\\beta\\), and the hazard function is \\[ h \\left( t \\right) = \\frac{\\beta} {\\eta} \\left( \\frac{t}{\\eta}\\right)^\\beta\\]\nwhere \\(\\eta\\) is the scale parameter, or characteristic life and \\(\\beta\\) is the shape parameter (or slope) The reliability function is thus \\[ R \\left( t \\right) = e^ {- \\left( \\frac{t}{\\eta} \\right) ^ \\beta} \\] It is easy to see:\nwhen \\(\\beta = 1\\), the h(t) is a flat line, a constant; when \\(\\beta \u0026gt; 1\\), the h(t) is monotonously increasing over time; when \\(\\beta \u0026lt; 1\\), the h(t) is monotonously increasing over time; While \\(\\beta\\) determines the shaple of curve, the \\(\\eta\\) determines the scale. \\(\\eta\\) is the time that no matter what \\(\\beta\\) is, \\(R \\left( t \\right) = e^{-1} = 63\\%\\), thus the name charasteristic life. Through my graduate schools, we used same parameterization in the textbooks ( Nelson and Modarres), except that \\(\\alpha\\) took the place of \\(\\eta\\). Give it a few years, I adjusted.\nYou can hear debate about \\(\\beta\\) and \\(\\eta\\) of a component around my office. Engineers love this simplicity.\nUntil there is none.\nConfusion Most Popular Stastical Software There is no denial that the by far most widely used statistical software is Excel, even though a unreliable one. Let’s look at the Weibull distribution implemented in Excel:\nWEIBULL(x,alpha,beta,cumulative)\nThe WEIBULL function syntax has the following arguments:\nX Required. The value at which to evaluate the function.\nAlpha, Beta Required, parameters to the distribution.\nCumulative Required. Determines the form of the function, if True, returns CDP, if false, pdf..\nThe equation for the Weibull cumulative distribution function is: \\[ F\\left( t; \\alpha, \\beta \\right) = 1 - e^ {- \\left( \\frac{t}{\\beta} \\right) ^ \\alpha}\\]\nWell, it not too bad, just my world upside down. \\(\\alpha\\) is \\(\\beta\\), and \\(\\beta\\) is \\(\\alpha\\). In excel, \\(\\beta\\) is scale, and \\(\\alpha\\) is shape.\nAlso, important to note that in Excel function call, only order matters, and you cannot force call by argument as in R.\nThe Upstart Welcome to R\nThe Weibull distribution with shape parameter a and scale parameter b has density given by f(x) = (a/b) (x/b)^(a-1) exp(- (x/b)^a) for x \u0026gt; 0. The cumulative distribution function is F(x) = 1 - exp(- (x/b)^a) on x \u0026gt; 0 So, a is shape, or \\(\\alpha\\). And b is scale, or \\(\\beta\\), as in Excel, not Nelson. When calling function with argument, as most do in R, it is less confusing.\nShape = 1 means constant as in most implementations, and scale is the characteristic life.\nt \u0026lt;- 0:1000 plot(t, pweibull(t, shape = 1, scale = 500)) And python See the doc from numpy:\nThe probability density for the Weibull distribution is \\[p\\left(x\\right)=\\frac{a}{\\lambda}\\cdot \\left(\\frac{x}{\\lambda}\\right)^{a-1}\\cdot e^{-\\left(x/b\\right)^a}\\] where \\(a\\) is the shape and \\(\\lambda\\) the scale.\nSame equation as r, except \\(\\lambda\\) is in the place of \\(b\\).\nJMP I love JMP. Not the software, I have not used for long enough to form an opinion. I love the help.\nVarious Weibull Parameters in Terms of JMP’s alpha and beta\nJMP Weibull alpha beta Wayne Nelson alpha=alpha beta=beta Meeker and Escobar eta=alpha beta=beta Tobias and Trindade c = alpha m = beta Kececioglu eta=alpha beta=beta Hosmer and Lemeshow exp(X beta)=alpha lambda=beta Blishke and Murthy beta=alpha alpha=beta Kalbfleisch and Prentice lambda = 1/alpha p = beta JMP Extreme Value lambda=log(alpha) delta=1/beta Meeker and Escobar mu=log(alpha) sigma=1/beta Final Thoughts Weibull distribution is used widely in engineering, biostatistics and other areas. The paramenterization has many ways. The most common used in engineering is the convention used in Nelson or Meeker. The shape factor is the characteristic life, called \\(\\alpha\\) or \\(\\eta\\), and shape factor \\(\\beta\\). …","date":1658534400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658621198,"objectID":"ba26accca31630bc2f3a8062d1132362","permalink":"/post/parameterizations-of-weibull-distribution/","publishdate":"2022-07-23T00:00:00Z","relpermalink":"/post/parameterizations-of-weibull-distribution/","section":"post","summary":"Repost The inline latex was not rendered if use .Rmarkdown extension, but it works when the extension is .Rmd. Most Widely Used Distribution in Reliability Engineering Weibull distribution is widely used because its flexibility and simplicity.","tags":[],"title":"Parameterizations of Weibull Distribution","type":"post"},{"authors":[],"categories":[],"content":"Just received my Stoic Bullion from Esty.\nThe fonts on the back is too small to read, but overall the build quality is good. It is creadit card size, and fits in my wallet.\nFour Virtues Wisdom Justice Courage Temperance Momento Praecepta\nActa Non Verba\nTO LIVE IN ACCORDANCE WITH NATURE MEMENTO MORI Do not act as if you had thousands of years to live. The unavoidable hangs above your head. While you have life in you, while you sill can, make yourself good. -Marcus Aurelius\nRemember death: To say this to tell a person to remember their freedom. -Sensca\nAct as if you have already died and what is left is now a gift. Now go live the rest properly. - Marcus Aurelius\nPREMEDITATIO MALORUM Everyone faces up more bravely to a thing for which he has long prepared himself, suffering can be withstood if they have been trained for in advance. -Seneca\nIf you wart a person to keep his head when a crisis comes you must give them training before it comes. -Seneca\nAll our human lot should be before our eyes. -Seneca\nAMOR FATI The spirit must be trainad to a realisation and an acceptance of its lot. -Seneca\nWhat fortune has made is not your own. -Seneca\nRemember that you are an actor in a play. For that is your business, to act the role that is assigned to you as well as you can. - Epicletus\nTEMET NOSCE To know thyself is the beginning of wisdom. -Aristotle\nThe unexamined life is not worth living. -Socrates\nTo find yourself, think for yeurself. -Socrates\nDig within. Therein lies the fountain of good. -Marcus Aurelius\n","date":1658448000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658548121,"objectID":"48072e71cf4d88c8e14a11e237f5a584","permalink":"/post/daily-stoic/","publishdate":"2022-07-22T00:00:00Z","relpermalink":"/post/daily-stoic/","section":"post","summary":"Just received my Stoic Bullion from Esty.\nThe fonts on the back is too small to read, but overall the build quality is good. It is creadit card size, and fits in my wallet.","tags":[],"title":"Daily Stoic","type":"post"},{"authors":[],"categories":["simulation","Reliability"],"content":" Discrete Event Simulation (DES) and Reliability Block Diagram (RBD) Discrete Event Simulation (DES) is the simulation of stochastic processes with discrete state space. An examploe of DES is the classic M/M/1 queue system: exponential interarrival and service times, with a single server. The state space can be defined as the queue length, which is integer-valued and thus “discrete.” This contrasts to, a continuous system, such as simulating a moving object, where state such as location is continuous.\nWhen we are dealing with complex system reliability, we have two dimensions:\nthe system reliability hierarchy, which is how component reliability impact the overall system performance the dyanmic response to an event, or state change, e.g. component failure, battery drain etc. (ref Yunwei Hu et al. 2022) System Reliability can be treated a DES problem, if we only consider discrete state of the components and not the continuous parameters. The classic System Reliability theories treat system state space as discrete, and most of the time, binary states.\nA reliability block diagram (RBD) is one of the most frequently used tool for modeling system reliability. It use a block diagram method to show how component reliability contributes to the success or failure of a complex system. It is a graphical representation of the boolenan logic of the system configuration.\nCommercial Reliability Software packages, such as Reliasoft Blocksim(R), use Reliability Block Diagram (RBD) to allow users to model the system and then use analytical or simulation methods to calculate the system reliability metrics. Thus, the RBD is used as a graphical interface to build the DES. However, the states are typcially binary, i.e. failure or success. Even though RBD is boolean only, the commercial software has added some dyanmic features, such as phased mission.\nIn a way, we can say RBD tools focus on the first aspect of the system reliability, and the genric DES tools focus on the second.\nIf the problem is about how the system design, such as redundancy, will impact the systme reliaiblity, RBD would be the preferred tool. It the problems involve complex dyanmic event sequences, and/or other non-binany system states, a generic DES might be preferred.\nDES in Python and R DES are implemented in commercial software and also as generic framework in Java, Python, etc. SimPy is a process-based discrete-event simulation framework implemented in Python. More recenlty, Simmer is developed as a process-oriented and trajectory-based Discrete-Event Simulation (DES) package for R. It is designed to be a generic framework like SimPy or SimJulia, and it runs the DES with Rcpp to boost the performance and turning DES in R feasible.\nThis post aims at evaluating Simpy and Simmer in the context of System Reliability.\nSimpy + Reticulate Reticulate package offers a set of tools for interoperability between Python and R. In this example, we use Reticulate to import a Simpy Model, and pass the simulation result to R as a data frame.\nMachie Shop Example Prepare the python library(tidyverse) library(reticulate) # use_python(\u0026#34;/Users/myhome/anaconda/bin/python\u0026#34;) use_miniconda(\u0026#34;base\u0026#34;) source_python(\u0026#34;simNHPP.py\u0026#34;) The Simpy Code See blow:\nimport random import simpy import pandas as pd RANDOM_SEED = 42 MTTF = 100.0 # Mean time to failure in minutes REPAIR_TIME = 2.0 # Time it takes to repair a machine in minutes NUM_MACHINES = 1 # Number of machines in the machine shop WEEKS = 4 # Simulation time in weeks SIM_TIME = WEEKS * 7 * 24 * 60 # Simulation time in minutes def simNHPP(end_sim): event_log = [] env = simpy.Environment() machine_1 = Machine(env, \u0026#34;Machine_1\u0026#34;, event_log) machine_2 = Machine(env, \u0026#34;Machine_2\u0026#34;, event_log) env.run(until = end_sim) event_log = pd.DataFrame(event_log, columns = [\u0026#39;event\u0026#39;,\u0026#39;time\u0026#39;]) return event_log def time_to_repair(): \u0026#34;\u0026#34;\u0026#34;return time interval until the repair is done, and machine is ready to run again. \u0026#34;\u0026#34;\u0026#34; return REPAIR_TIME def time_to_failure(): \u0026#34;\u0026#34;\u0026#34;Return time until next failure for a machine.\u0026#34;\u0026#34;\u0026#34; return random.expovariate(1.0/MTTF) # each machine has a name, and pass the event_log # time to failure and time to repair are defined globally. class Machine: def __init__(self, env, name, event_log): self.env = env self.name = str(name) self.work_proc = env.process(self.working(env, event_log)) def working(self, env, event_log): while True: # Up until failure time_to_fail = time_to_failure() # print(\u0026#39;%s: time to next failure is %.2f\u0026#39; % (self.name, time_to_fail)) yield env.timeout(time_to_fail) # Repair for time_to_repair # print(\u0026#34;%s Failure Starts at %.2f\u0026#34; % (self.name, env.now)) event_log.append([self.name + \u0026#34; fails\u0026#34;, env.now]) repair_time = time_to_repair() yield env.timeout(repair_time) # print(\u0026#34;%s is repaired at %.2f\u0026#34; % (self.name, env.now)) event_log.append([self.name + \u0026#34; fixed\u0026#34;, env.now]) Simulation ptm \u0026lt;- proc.time() ev \u0026lt;- 1:1000 %\u0026gt;% map_df(function(x) cbind(simNHPP(SIM_TIME), tibble(n_run = x))) map_time \u0026lt;- proc.time() - ptm …","date":1658448000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658550570,"objectID":"0d35b42c58ee4f35d3ce7223895757eb","permalink":"/post/discrete-event-simulation/","publishdate":"2022-07-22T00:00:00Z","relpermalink":"/post/discrete-event-simulation/","section":"post","summary":"Discrete Event Simulation (DES) and Reliability Block Diagram (RBD) Discrete Event Simulation (DES) is the simulation of stochastic processes with discrete state space. An examploe of DES is the classic M/M/1 queue system: exponential interarrival and service times, with a single server.","tags":["DES","Repairable","python","rstats"],"title":"Discrete Event Simulation","type":"post"},{"authors":[],"categories":[],"content":"I stopped updating this blog since 2020 serveral months into the pandemic. When I checked again this week, quite a few things were broken, hugo, shiny and latex, just to name a few.\nI am in the process to repost the old posts, and found that as of today, July 2022, reticulate is imcompatible with the Anacodna distro, even though Anacodna has a M1 distro since May, 2022.\nThe workaround is\nuninstall anaconda use reticulate::install_miniconda Install packages to the env of your choice then reticulate::use_miniconda(env) It is fairly straightforward. Hopefully reticulate will be compatible with Anaconda in future updates.\n","date":1658448000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658559247,"objectID":"885c73a92c4da2199e024af74e2f3069","permalink":"/post/use-python-via-reticulate-on-macbook-m1/","publishdate":"2022-07-22T00:00:00Z","relpermalink":"/post/use-python-via-reticulate-on-macbook-m1/","section":"post","summary":"I stopped updating this blog since 2020 serveral months into the pandemic. When I checked again this week, quite a few things were broken, hugo, shiny and latex, just to name a few.","tags":[],"title":"Use python via reticulate on Macbook M1","type":"post"},{"authors":[],"categories":[],"content":"Probabilistic Models for Repairable Systerms When analyzing repairable systems, areas of interest may include assessing the expected number of failures during the warranty period, maintaining a minimum mission reliability, evaluating the rate of wearout, determining when to replace or overhaul a system and minimizing life cycle costs.\nWhen the downtime of the repairable systems are short, the point processes are often the model of choice. A point process gives:\nN(t): a counting function that keeps track of the cumulative number of failures a given system has had from time zero to time t. N(t) is a step function that jumps up one every time a failure occurs and stays at the new level until the next failure. M(t) = E[N(t)] : the expected number (average number) of cumulative failures by time t for these systems. The Repair Rate (the Rate Of Occurrence Of Failures, or ROCOF) is the mean rate of failures per unit time. Mathematically, it is derivative of M(t), denoted m(t). It is also called intensity function in theory of random process. Power Law NHPP and Underlying Weibull The NHPP model is has a model for minimal repair, where the repair of a failed system is just enough to get the system operational again. In Power Law NHPP, the time to first failure follows the Weibull distribution, then each succeeding failure is governed by the model as in the case of minimal repair.\nFor Power Law NHPP model, the expected number of failures in the first t hours, M(t), is: $$E\\left[ N(t) \\right] =\\lambda\\cdot t^\\beta$$ where $\\lambda,\\beta\u0026gt;0$. The probability that the number of failures, N(t), is: $$Pr\\left[ N \\left( t \\right)= n \\right]=\\frac{\\left( \\lambda \\cdot t^\\beta \\right) \\cdot e^{-\\lambda \\cdot t^\\beta}} {n!} ;n=0,1,2,… $$\nThe repair rate (or ROCOF) for this model is $$ m(t)=\\lambda\\cdot \\beta \\cdot t^{\\beta−1}$$ where $\\lambda\u0026gt;0,\\beta \u0026gt; 0$.\nFor a Power Law NHPP process, the time to the first fail follows a Weibull distribution with shape parameter $\\beta$ and characteristic life $\\eta=\\left( \\lambda \\right) ^ {- \\frac {1} {\\beta}}$. The accumulated Hazard function: $$H\\left(t \\right)=\\lambda\\cdot t^\\beta$$ Culmative Distribution Function $$F\\left( t \\right) = 1-e^{-\\lambda \\cdot t^\\beta}$$\nOther names for the Power Law model are: the Duane Model and the AMSAA model. AMSAA stands for the United States Army Materials System Analysis Activity, where much theoretical work describing the Power Law model was performed in the 1970’s.\nNHPP and the Underlying Weibull time-to-failure The reliability function always follows $$R\\left( t \\right)=1-F\\left( t \\right) = e^{-H\\left( t \\right)}$$ and $$ H\\left( t \\right) = -\\ln\\left[ R\\left( t \\right) \\right]=-\\ln \\left[ 1-F\\left( t \\right) \\right]$$\nAs bad as old Meaning of $\\beta$ When $\\beta=1$, it becomes a HPP model, where $m(t)=\\lambda$.\n$E \\left[ N \\left( t \\right) \\right] =\\lambda\\cdot T$, is just a straight line, and the slope is $\\beta$.\ntodo insert plots of m(t), M(t) when beta = 0.5, 1, 2, 4\nReference NHPP http://www.itl.nist.gov/div898/handbook/apr/section1/apr172.htm Weibull http://www.itl.nist.gov/div898/handbook/apr/section1/apr162.htm Power Law RGA http://www.weibull.com/hotwire/issue131/relbasics131.htm Reliasoft NHPP http://reliawiki.org/index.php/Crow-AMSAA_(NHPP) https://stats.stackexchange.com/questions/49012/how-to-estimate-poisson-process-using-r-or-how-to-use-nhpoisson-package Repairable Systems http://www.itl.nist.gov/div898/handbook/apr/section1/apr125.htm Marvin Rausand, Arnljot Høyland; System Reliability Theory: Models, Statistical Methods, and Applications, 2nd Edition Mohammad Modarres - Reliability Engineering and Risk Analysis: A Practical Guide, Second Edition (2nd Edition) (8/23/09) ","date":1658361600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658388787,"objectID":"5d6b72fa9a1c127b10966694fdd57d45","permalink":"/post/repairable-systems-and-nhpp/","publishdate":"2022-07-21T00:00:00Z","relpermalink":"/post/repairable-systems-and-nhpp/","section":"post","summary":"Probabilistic Models for Repairable Systerms When analyzing repairable systems, areas of interest may include assessing the expected number of failures during the warranty period, maintaining a minimum mission reliability, evaluating the rate of wearout, determining when to replace or overhaul a system and minimizing life cycle costs.","tags":[],"title":"Repairable Systems and NHPP","type":"post"},{"authors":["Yunwei Hu","Tarannom Parhizkar","Ali Mosleh"],"categories":null,"content":"","date":1640995200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1640995200,"objectID":"978c1d0c540662503508f3588f6ea8ff","permalink":"/publication/ress2022/","publishdate":"2022-01-01T00:00:00Z","relpermalink":"/publication/ress2022/","section":"publication","summary":"Probabilistic risk assessment (PRA) is a systematic process of examining how engineered systems work to ensure safety. With the growth of the size of dynamic systems and the complexity of the interactions between hardware, software, and humans, it is extremely difficult to enumerate risky scenarios by the traditional PRA methods. In this study, a new dynamic probabilistic risk assessment methodology is proposed that employs a new exploration strategy to generate risky scenarios. The proposed methodology consists of three main modules, including simulation, planner, and scheduler. In this methodology, the engineering knowledge of the system is explicitly used to guide the simulation module to achieve higher efficiency and accuracy. The engineering knowledge is reflected in the planner module which is responsible for generating plans as a high-level map to guide the simulation. The scheduler module is responsible for guiding the simulation by controlling the timing and occurrence of the random events. In this paper, modules of the proposed methodology, and their interactions are explained in detail. The developed methodology is used to perform risk assessment of a Space Shuttle ascent phase, and results show the effectiveness of the proposed platform..","tags":[],"title":"Guided simulation for dynamic probabilistic risk assessment of complex systems: Concept, method, and application","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\nFeatures Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides Controls Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;) Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne Two Three A fragment can accept two optional parameters:\nclass: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\nOnly the speaker can read these notes Press S key to view Themes black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/media/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}} Custom CSS Example Let’s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; } Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"e8f8d235e8e7f2efd912bfe865363fc3","permalink":"/project/example/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/example/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Example Project","type":"project"}]